// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package flow

import (
	"context"
	"sync"

	"github.com/cappuccinotm/dastracker/app/store"
)

// Ensure, that InterfaceMock does implement Interface.
// If this is not the case, regenerate this file with moq.
var _ Interface = &InterfaceMock{}

// InterfaceMock is a mock implementation of Interface.
//
//     func TestSomethingThatUsesInterface(t *testing.T) {
//
//         // make and configure a mocked Interface
//         mockedInterface := &InterfaceMock{
//             GetSubscribedJobsFunc: func(ctx context.Context, triggerName string) ([]store.Job, error) {
// 	               panic("mock out the GetSubscribedJobs method")
//             },
//             GetTrackersFunc: func(in1 context.Context) ([]Tracker, error) {
// 	               panic("mock out the GetTrackers method")
//             },
//         }
//
//         // use mockedInterface in code that requires Interface
//         // and then make assertions.
//
//     }
type InterfaceMock struct {
	// GetSubscribedJobsFunc mocks the GetSubscribedJobs method.
	GetSubscribedJobsFunc func(ctx context.Context, triggerName string) ([]store.Job, error)

	// GetTrackersFunc mocks the GetTrackers method.
	GetTrackersFunc func(in1 context.Context) ([]Tracker, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetSubscribedJobs holds details about calls to the GetSubscribedJobs method.
		GetSubscribedJobs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TriggerName is the triggerName argument value.
			TriggerName string
		}
		// GetTrackers holds details about calls to the GetTrackers method.
		GetTrackers []struct {
			// In1 is the in1 argument value.
			In1 context.Context
		}
	}
	lockGetSubscribedJobs sync.RWMutex
	lockGetTrackers       sync.RWMutex
}

// GetSubscribedJobs calls GetSubscribedJobsFunc.
func (mock *InterfaceMock) GetSubscribedJobs(ctx context.Context, triggerName string) ([]store.Job, error) {
	if mock.GetSubscribedJobsFunc == nil {
		panic("InterfaceMock.GetSubscribedJobsFunc: method is nil but Interface.GetSubscribedJobs was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		TriggerName string
	}{
		Ctx:         ctx,
		TriggerName: triggerName,
	}
	mock.lockGetSubscribedJobs.Lock()
	mock.calls.GetSubscribedJobs = append(mock.calls.GetSubscribedJobs, callInfo)
	mock.lockGetSubscribedJobs.Unlock()
	return mock.GetSubscribedJobsFunc(ctx, triggerName)
}

// GetSubscribedJobsCalls gets all the calls that were made to GetSubscribedJobs.
// Check the length with:
//     len(mockedInterface.GetSubscribedJobsCalls())
func (mock *InterfaceMock) GetSubscribedJobsCalls() []struct {
	Ctx         context.Context
	TriggerName string
} {
	var calls []struct {
		Ctx         context.Context
		TriggerName string
	}
	mock.lockGetSubscribedJobs.RLock()
	calls = mock.calls.GetSubscribedJobs
	mock.lockGetSubscribedJobs.RUnlock()
	return calls
}

// GetTrackers calls GetTrackersFunc.
func (mock *InterfaceMock) GetTrackers(in1 context.Context) ([]Tracker, error) {
	if mock.GetTrackersFunc == nil {
		panic("InterfaceMock.GetTrackersFunc: method is nil but Interface.GetTrackers was just called")
	}
	callInfo := struct {
		In1 context.Context
	}{
		In1: in1,
	}
	mock.lockGetTrackers.Lock()
	mock.calls.GetTrackers = append(mock.calls.GetTrackers, callInfo)
	mock.lockGetTrackers.Unlock()
	return mock.GetTrackersFunc(in1)
}

// GetTrackersCalls gets all the calls that were made to GetTrackers.
// Check the length with:
//     len(mockedInterface.GetTrackersCalls())
func (mock *InterfaceMock) GetTrackersCalls() []struct {
	In1 context.Context
} {
	var calls []struct {
		In1 context.Context
	}
	mock.lockGetTrackers.RLock()
	calls = mock.calls.GetTrackers
	mock.lockGetTrackers.RUnlock()
	return calls
}
