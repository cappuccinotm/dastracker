// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package logx

import (
	"sync"
)

// Ensure, that LoggerMock does implement Logger.
// If this is not the case, regenerate this file with moq.
var _ Logger = &LoggerMock{}

// LoggerMock is a mock implementation of Logger.
//
// 	func TestSomethingThatUsesLogger(t *testing.T) {
//
// 		// make and configure a mocked Logger
// 		mockedLogger := &LoggerMock{
// 			PrintfFunc: func(s string, args ...interface{})  {
// 				panic("mock out the Printf method")
// 			},
// 			SubFunc: func(p string) Logger {
// 				panic("mock out the Sub method")
// 			},
// 		}
//
// 		// use mockedLogger in code that requires Logger
// 		// and then make assertions.
//
// 	}
type LoggerMock struct {
	// PrintfFunc mocks the Printf method.
	PrintfFunc func(s string, args ...interface{})

	// SubFunc mocks the Sub method.
	SubFunc func(p string) Logger

	// calls tracks calls to the methods.
	calls struct {
		// Printf holds details about calls to the Printf method.
		Printf []struct {
			// S is the s argument value.
			S string
			// Args is the args argument value.
			Args []interface{}
		}
		// Sub holds details about calls to the Sub method.
		Sub []struct {
			// P is the p argument value.
			P string
		}
	}
	lockPrintf sync.RWMutex
	lockSub    sync.RWMutex
}

// Printf calls PrintfFunc.
func (mock *LoggerMock) Printf(s string, args ...interface{}) {
	if mock.PrintfFunc == nil {
		panic("LoggerMock.PrintfFunc: method is nil but Logger.Printf was just called")
	}
	callInfo := struct {
		S    string
		Args []interface{}
	}{
		S:    s,
		Args: args,
	}
	mock.lockPrintf.Lock()
	mock.calls.Printf = append(mock.calls.Printf, callInfo)
	mock.lockPrintf.Unlock()
	mock.PrintfFunc(s, args...)
}

// PrintfCalls gets all the calls that were made to Printf.
// Check the length with:
//     len(mockedLogger.PrintfCalls())
func (mock *LoggerMock) PrintfCalls() []struct {
	S    string
	Args []interface{}
} {
	var calls []struct {
		S    string
		Args []interface{}
	}
	mock.lockPrintf.RLock()
	calls = mock.calls.Printf
	mock.lockPrintf.RUnlock()
	return calls
}

// Sub calls SubFunc.
func (mock *LoggerMock) Sub(p string) Logger {
	if mock.SubFunc == nil {
		panic("LoggerMock.SubFunc: method is nil but Logger.Sub was just called")
	}
	callInfo := struct {
		P string
	}{
		P: p,
	}
	mock.lockSub.Lock()
	mock.calls.Sub = append(mock.calls.Sub, callInfo)
	mock.lockSub.Unlock()
	return mock.SubFunc(p)
}

// SubCalls gets all the calls that were made to Sub.
// Check the length with:
//     len(mockedLogger.SubCalls())
func (mock *LoggerMock) SubCalls() []struct {
	P string
} {
	var calls []struct {
		P string
	}
	mock.lockSub.RLock()
	calls = mock.calls.Sub
	mock.lockSub.RUnlock()
	return calls
}
